<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[spring 集成 websocket]]></title>
      <url>%2F2017%2F04%2F21%2Fspring-%E9%9B%86%E6%88%90-websocket%2F</url>
      <content type="text"><![CDATA[spring4.0以后加入了对websocket技术的支持，目前项目用的是SSM（springMVC+spring+MyBatis）框架，所以选择了spring自带的websocket。 开始集成:在pom.xml文件中增加以下依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.websocket&lt;/groupId&gt; &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 握手拦截器12345678910111213141516171819public class WebSocketHandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123; @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; if (request instanceof ServletServerHttpRequest) &#123; String openid = ((ServletServerHttpRequest) request).getServletRequest().getParameter("openid"); attributes.put("WEBSOCKET_USERNAME", openid); &#125; return super.beforeHandshake(request, response, wsHandler, attributes); &#125; @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) &#123; super.afterHandshake(request, response, wsHandler, ex); &#125;&#125; 业务拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class UnionpaySocketHandler extends TextWebSocketHandler &#123; private static final Logger logger = LoggerFactory.getLogger(UnionpaySocketHandler.class); private final static ConcurrentMap&lt;String, WebSocketSession&gt; sessions; static &#123; sessions = new ConcurrentHashMap&lt;&gt;(); &#125; //接收文本消息，并发送出去 @Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123; String msg = message.getPayload(); TextMessage returnMessage = new TextMessage(msg); session.sendMessage(returnMessage); super.handleTextMessage(session, message); &#125; //连接建立后处理 @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; String openid = (String) session.getAttributes().get("WEBSOCKET_USERNAME"); if (StringUtils.isNotBlank(openid)) &#123; logger.info("用户 &gt;&gt; &#123;&#125; 建立连接", openid); sessions.put(openid, session); &#125; &#125; //抛出异常时处理 @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; if (session.isOpen()) &#123; session.close(); &#125; String openid = (String) session.getAttributes().get("WEBSOCKET_USERNAME"); sessions.remove(openid); &#125; //连接关闭后处理 @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception &#123; String openid = (String) session.getAttributes().get("WEBSOCKET_USERNAME"); logger.info("用户 &gt;&gt; &#123;&#125; 退出连接", openid); sessions.remove(openid); &#125; /** * 给某个用户发送消息 * * @param userName * @param msg */ public void sendMessageToUser(String userName, String msg) &#123; WebSocketSession session = sessions.get(userName); if (session != null) &#123; try &#123; TextMessage message = new TextMessage(msg); session.sendMessage(message); &#125; catch (IOException e) &#123; logger.error("发送信息异常, ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; &#125; &#125;&#125; 配置类12345678910111213141516171819202122232425262728@Configuration@EnableWebSocketpublic class WebSocketConfiguration extends WebMvcConfigurerAdapter implements WebSocketConfigurer &#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; registry .addHandler(unionpaySocketHandler(), "/unionpayServer") .setAllowedOrigins("*")//允许所有域访问 .addInterceptors(myInterceptor()); registry .addHandler(unionpaySocketHandler(), "/unionpayServer/sockjs") .setAllowedOrigins("*") .addInterceptors(myInterceptor()) .withSockJS(); &#125; @Bean public UnionpaySocketHandler unionpaySocketHandler() &#123; return new UnionpaySocketHandler(); &#125; @Bean public WebSocketHandshakeInterceptor myInterceptor() &#123; return new WebSocketHandshakeInterceptor(); &#125;&#125; web.xml增加配置12345678910&lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; **&lt;async-supported&gt;true&lt;/async-supported&gt;//需要增加此项 允许异步(未测试是否必须配置)&lt;/servlet&gt; 以下重点如果使用了nginx做代理，则nginx需要增加配置，否则websocket开启会报错301或者400或者500等 以下为例子 1234567location /websocket &#123; proxy_pass http://127.0.0.1:9090/unionpayServer; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_read_timeout 300s;&#125; 前端调用方法示例1websocket = new WebSocket("ws://localhost:8080/websocket?openid=123");//如果为https,ws改为wss 至此，整个websocket集成配置已完成。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F20%2Fhello%20world%2F</url>
      <content type="text"><![CDATA[Hello, this world！ 没有啦~~~]]></content>
    </entry>

    
  
  
</search>
