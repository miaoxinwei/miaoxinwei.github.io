<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[不同版本(2.5-3.1) web.xml文件的schema头部声明]]></title>
      <url>%2F2017%2F04%2F25%2F%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC-2-5-3-1-web-xml%E6%96%87%E4%BB%B6%E7%9A%84schema%E5%A4%B4%E9%83%A8%E5%A3%B0%E6%98%8E%2F</url>
      <content type="text"><![CDATA[项目用的容器是tomcat8, tomcat8 默认的是servlet 3.1的版本, 看了下 web.xml还是3.0的版本, 所以升级了下, 顺便贴一下2.5到3.1的schema头部声明。 1. Servlet 3.1Java EE 7 XML schema，命名空间是 http://xmlns.jcp.org/xml/ns/javaee/ 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;/web-app&gt; 2. Servlet 3.0Java EE 6 XML schema，命名空间是 http://java.sun.com/xml/ns/javaee 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt;&lt;/web-app&gt; 3. Servlet 2.5Java EE 5 XML schema，命名空间是 http://java.sun.com/xml/ns/javaee 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt;&lt;/web-app&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring 集成 okhttp3]]></title>
      <url>%2F2017%2F04%2F21%2Fspring-%E9%9B%86%E6%88%90-okhttp3%2F</url>
      <content type="text"><![CDATA[前言okhttp 介绍 HTTP is the way modern applications network. It’s how we exchange data &amp; media. &gt;Doing HTTP efficiently makes your stuff load faster and saves bandwidth. OkHttp is an HTTP client that’s efficient by default: HTTP/2 support allows all requests to the same host to share a socket. Connection pooling reduces request latency (if HTTP/2 isn’t available). Transparent GZIP shrinks download sizes. Response caching avoids the network completely for repeat requests. OkHttp perseveres when the network is troublesome: it will silently recover from &gt; &gt;common connection problems. If your service has multiple IP addresses OkHttp will &gt;attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6 &gt;and for services hosted in redundant data centers. OkHttp initiates new connections &gt;with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake fails. Using OkHttp is easy. Its request/response API is designed with fluent builders and immutability. It supports both synchronous blocking calls and async calls with callbacks. OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7. —摘自 https://square.github.io/okhttp/ 准备工作在pom.xml文件中增加以下依赖12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt; 书写配置类 用@Configuration注解该类，等价与XML中配置beans；用@Bean标注方法等价于XML中配置bean。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Configurationpublic class OkHttpConfiguration &#123; @Bean public X509TrustManager x509TrustManager() &#123; return new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125;; &#125; @Bean public SSLSocketFactory sslSocketFactory() &#123; try &#123; //信任任何链接 SSLContext sslContext = SSLContext.getInstance("TLS"); sslContext.init(null, new TrustManager[]&#123;x509TrustManager()&#125;, new SecureRandom()); return sslContext.getSocketFactory(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * Create a new connection pool with tuning parameters appropriate for a single-user application. * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently */ @Bean public ConnectionPool pool() &#123; return new ConnectionPool(200, 5, TimeUnit.MINUTES); &#125; @Bean public OkHttpClient okHttpClient() &#123; return new OkHttpClient.Builder() .sslSocketFactory(sslSocketFactory(), x509TrustManager()) .retryOnConnectionFailure(false)//是否开启缓存 .connectionPool(pool())//连接池 .connectTimeout(10L, TimeUnit.SECONDS) .readTimeout(10L, TimeUnit.SECONDS) .build(); &#125;&#125; 工具类 自己写的工具类，比较简单，不是REST风格 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147@Componentpublic class OkHttpUtil &#123; private static final Logger logger = LoggerFactory.getLogger(OkHttpUtil.class); @Resource private OkHttpClient okHttpClient; /** * get * * @param url 请求的url * @param queries 请求的参数，在浏览器？后面的数据，没有可以传null * @return */ public String get(String url, Map&lt;String, String&gt; queries) &#123; String responseBody = ""; StringBuffer sb = new StringBuffer(url); if (queries != null &amp;&amp; queries.keySet().size() &gt; 0) &#123; boolean firstFlag = true; Iterator iterator = queries.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry&lt;String, String&gt;) iterator.next(); if (firstFlag) &#123; sb.append("?" + entry.getKey() + "=" + entry.getValue()); firstFlag = false; &#125; else &#123; sb.append("&amp;" + entry.getKey() + "=" + entry.getValue()); &#125; &#125; &#125; Request request = new Request .Builder() .url(sb.toString()) .build(); Response response = null; try &#123; response = okHttpClient.newCall(request).execute(); int status = response.code(); if (status == 200) &#123; return response.body().string(); &#125; &#125; catch (Exception e) &#123; logger.error("okhttp put error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; finally &#123; if (response != null) &#123; response.close(); &#125; &#125; return responseBody; &#125; /** * post * * @param url 请求的url * @param params post form 提交的参数 * @return */ public String post(String url, Map&lt;String, String&gt; params) &#123; String responseBody = ""; FormBody.Builder builder = new FormBody.Builder(); //添加参数 if (params != null &amp;&amp; params.keySet().size() &gt; 0) &#123; for (String key : params.keySet()) &#123; builder.add(key, params.get(key)); &#125; &#125; Request request = new Request .Builder() .url(url) .post(builder.build()) .build(); Response response = null; try &#123; response = okHttpClient.newCall(request).execute(); int status = response.code(); if (status == 200) &#123; return response.body().string(); &#125; &#125; catch (Exception e) &#123; logger.error("okhttp post error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; finally &#123; if (response != null) &#123; response.close(); &#125; &#125; return responseBody; &#125; /** * post 上传文件 * * @param url * @param params * @param fileType * @return */ public String postFile(String url, Map&lt;String, Object&gt; params, String fileType) &#123; String responseBody = ""; MultipartBody.Builder builder = new MultipartBody.Builder(); //添加参数 if (params != null &amp;&amp; params.keySet().size() &gt; 0) &#123; for (String key : params.keySet()) &#123; if (params.get(key) instanceof File) &#123; File file = (File) params.get(key); builder.addFormDataPart(key, file.getName(), RequestBody.create(MediaType.parse(fileType), file)); continue; &#125; builder.addFormDataPart(key, params.get(key).toString()); &#125; &#125; Request request = new Request .Builder() .url(url) .post(builder.build()) .build(); Response response = null; try &#123; response = okHttpClient.newCall(request).execute(); int status = response.code(); if (status == 200) &#123; return response.body().string(); &#125; &#125; catch (Exception e) &#123; logger.error("okhttp postFile error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; finally &#123; if (response != null) &#123; response.close(); &#125; &#125; return responseBody; &#125;&#125; 使用方法12@Resourceprivate OkHttpUtil okHttpUtil;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring 集成 websocket]]></title>
      <url>%2F2017%2F04%2F21%2Fspring-%E9%9B%86%E6%88%90-websocket%2F</url>
      <content type="text"><![CDATA[spring4.0以后加入了对websocket技术的支持，目前项目用的是SSM（springMVC+spring+MyBatis）框架，所以选择了spring自带的websocket。 开始集成:在pom.xml文件中增加以下依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.websocket&lt;/groupId&gt; &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 握手拦截器12345678910111213141516171819public class WebSocketHandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123; @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; if (request instanceof ServletServerHttpRequest) &#123; String openid = ((ServletServerHttpRequest) request).getServletRequest().getParameter("openid"); attributes.put("WEBSOCKET_USERNAME", openid); &#125; return super.beforeHandshake(request, response, wsHandler, attributes); &#125; @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) &#123; super.afterHandshake(request, response, wsHandler, ex); &#125;&#125; 业务拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class UnionpaySocketHandler extends TextWebSocketHandler &#123; private static final Logger logger = LoggerFactory.getLogger(UnionpaySocketHandler.class); private final static ConcurrentMap&lt;String, WebSocketSession&gt; sessions; static &#123; sessions = new ConcurrentHashMap&lt;&gt;(); &#125; //接收文本消息，并发送出去 @Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123; String msg = message.getPayload(); TextMessage returnMessage = new TextMessage(msg); session.sendMessage(returnMessage); super.handleTextMessage(session, message); &#125; //连接建立后处理 @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; String openid = (String) session.getAttributes().get("WEBSOCKET_USERNAME"); if (StringUtils.isNotBlank(openid)) &#123; logger.info("用户 &gt;&gt; &#123;&#125; 建立连接", openid); sessions.put(openid, session); &#125; &#125; //抛出异常时处理 @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; if (session.isOpen()) &#123; session.close(); &#125; String openid = (String) session.getAttributes().get("WEBSOCKET_USERNAME"); sessions.remove(openid); &#125; //连接关闭后处理 @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception &#123; String openid = (String) session.getAttributes().get("WEBSOCKET_USERNAME"); logger.info("用户 &gt;&gt; &#123;&#125; 退出连接", openid); sessions.remove(openid); &#125; /** * 给某个用户发送消息 * * @param userName * @param msg */ public void sendMessageToUser(String userName, String msg) &#123; WebSocketSession session = sessions.get(userName); if (session != null) &#123; try &#123; TextMessage message = new TextMessage(msg); session.sendMessage(message); &#125; catch (IOException e) &#123; logger.error("发送信息异常, ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; &#125; &#125;&#125; 配置类12345678910111213141516171819202122232425262728@Configuration@EnableWebSocketpublic class WebSocketConfiguration implements WebSocketConfigurer &#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; registry .addHandler(unionpaySocketHandler(), "/unionpayServer") .setAllowedOrigins("*")//允许所有域访问 .addInterceptors(myInterceptor()); registry .addHandler(unionpaySocketHandler(), "/unionpayServer/sockjs") .setAllowedOrigins("*") .addInterceptors(myInterceptor()) .withSockJS(); &#125; @Bean public UnionpaySocketHandler unionpaySocketHandler() &#123; return new UnionpaySocketHandler(); &#125; @Bean public WebSocketHandshakeInterceptor myInterceptor() &#123; return new WebSocketHandshakeInterceptor(); &#125;&#125; web.xml增加配置12345678910&lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; **&lt;async-supported&gt;true&lt;/async-supported&gt;//需要增加此项 允许异步(未测试是否必须配置)&lt;/servlet&gt; 以下重点如果使用了nginx做代理，则nginx需要增加配置，否则websocket开启会报错301或者400或者500等 以下为例子 1234567location /websocket &#123; proxy_pass http://127.0.0.1:9090/unionpayServer; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_read_timeout 300s;&#125; 前端调用方法示例1websocket = new WebSocket("ws://localhost:8080/websocket?openid=123");//如果为https,ws改为wss 至此，整个websocket集成配置已完成。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F20%2Fhello%20world%2F</url>
      <content type="text"><![CDATA[Hello, this world！ 没有啦~~~]]></content>
    </entry>

    
  
  
</search>
