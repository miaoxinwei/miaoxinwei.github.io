<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[spring 集成数据源 HiKariCP]]></title>
      <url>%2F2017%2F05%2F12%2Fspring-%E9%9B%86%E6%88%90%E6%95%B0%E6%8D%AE%E6%BA%90-HiKariCP%2F</url>
      <content type="text"><![CDATA[前言摘自Github Fast, simple, reliable. HikariCP is a “zero-overhead” production ready JDBC connection pool. At roughly 130Kb, the library is very light. Read about how we do it here. 官网：https://github.com/brettwooldridge/HikariCP]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring 集成 httpclient]]></title>
      <url>%2F2017%2F04%2F25%2Fspring-%E9%9B%86%E6%88%90-httpclient%2F</url>
      <content type="text"><![CDATA[前言httpclient 介绍 The Hyper-Text Transfer Protocol (HTTP) is perhaps the most significant protocol used on the Internet today. Web services, network-enabled appliances and the growth of network computing continue to expand the role of the HTTP protocol beyond user-driven web browsers, while increasing the number of applications that require HTTP support.Although the java.net package provides basic functionality for accessing resources via HTTP, it doesn’t provide the full flexibility or functionality needed by many applications. HttpClient seeks to fill this void by providing an efficient, up-to-date, and feature-rich package implementing the client side of the most recent HTTP standards and recommendations.Designed for extension while providing robust support for the base HTTP protocol, HttpClient may be of interest to anyone building HTTP-aware client applications such as web browsers, web service clients, or systems that leverage or extend the HTTP protocol for distributed communication. 准备工作在pom.xml文件中增加以下依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 书写配置类 用@Configuration注解该类，等价与XML中配置beans；用@Bean标注方法等价于XML中配置bean。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Configurationpublic class HttpConfiguration &#123; @Bean public LayeredConnectionSocketFactory sslSF() &#123; LayeredConnectionSocketFactory sslSF = null; try &#123; KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); //信任任何链接 SSLContext sslContext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustStrategy() &#123; @Override public boolean isTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; return true; &#125; &#125;).build(); return new SSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return sslSF; &#125; @Bean public Registry&lt;ConnectionSocketFactory&gt; registryBuilder() &#123; return RegistryBuilder.&lt;ConnectionSocketFactory&gt;create() .register("https", sslSF()) .register("http", new PlainConnectionSocketFactory()) .build(); &#125; @Bean public PoolingHttpClientConnectionManager connectionManager() &#123; PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(registryBuilder()); connectionManager.setMaxTotal(500); connectionManager.setDefaultMaxPerRoute(500); return connectionManager; &#125; @Bean public CloseableHttpClient httpClient() &#123; return HttpClients.custom() .setConnectionManager(connectionManager()) .build(); &#125; @Bean public RequestConfig requestConfig() &#123; return RequestConfig.custom() .setConnectTimeout(10000) .setConnectionRequestTimeout(500) .setSocketTimeout(10000) .build(); &#125; @Bean(destroyMethod = "shutdown") public IdleConnectionEvictor idleConnectionEvictor() &#123; return new IdleConnectionEvictor(connectionManager()); &#125;&#125; 定期清理无效的http连接1234567891011121314151617181920212223242526272829303132333435public class IdleConnectionEvictor extends Thread &#123; private final HttpClientConnectionManager connMgr; private volatile boolean shutdown; public IdleConnectionEvictor(HttpClientConnectionManager connMgr) &#123; super(); this.connMgr = connMgr; // 启动当前线程 this.start(); &#125; @Override public void run() &#123; try &#123; while (!shutdown) &#123; synchronized (this) &#123; wait(5000); // 关闭失效的连接 connMgr.closeExpiredConnections(); &#125; &#125; &#125; catch (InterruptedException ex) &#123; // 结束 &#125; &#125; public void shutdown() &#123; shutdown = true; synchronized (this) &#123; notifyAll(); &#125; &#125;&#125; 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234@Componentpublic class HttpClientUtil &#123; private static final Logger logger = LoggerFactory.getLogger(HttpClientUtil.class); @Resource private CloseableHttpClient httpClient; @Resource private RequestConfig requestConfig; /** * get * * @param url 请求的url * @param queries 请求的参数，在浏览器？后面的数据，没有可以传null * @return */ public String get(String url, Map&lt;String, String&gt; queries) &#123; String responseBody = ""; //支持https StringBuffer sb = new StringBuffer(url); if (queries != null &amp;&amp; queries.keySet().size() &gt; 0) &#123; boolean firstFlag = true; Iterator iterator = queries.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry&lt;String, String&gt;) iterator.next(); if (firstFlag) &#123; sb.append("?" + entry.getKey() + "=" + entry.getValue()); firstFlag = false; &#125; else &#123; sb.append("&amp;" + entry.getKey() + "=" + entry.getValue()); &#125; &#125; &#125; HttpGet httpGet = new HttpGet(sb.toString()); //设置超时 httpGet.setConfig(this.requestConfig); //请求数据 CloseableHttpResponse response = null; try &#123; response = this.httpClient.execute(httpGet); int status = response.getStatusLine().getStatusCode(); if (status == HttpStatus.SC_OK) &#123; HttpEntity entity = response.getEntity(); responseBody = EntityUtils.toString(entity);// EntityUtils.consume(response.getEntity()); //会自动释放连接 &#125; &#125; catch (Exception ex) &#123; logger.error("http error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(ex)); &#125; finally &#123; if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; logger.error("http close error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; &#125; &#125; return responseBody; &#125; /** * get * * @param url 请求的url * @param queries 请求的参数，在浏览器？后面的数据，没有可以传null * @return */ public File getFile(String url, Map&lt;String, String&gt; queries, File file) &#123; //支持https StringBuffer sb = new StringBuffer(url); if (queries != null &amp;&amp; queries.keySet().size() &gt; 0) &#123; boolean firstFlag = true; Iterator iterator = queries.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry&lt;String, String&gt;) iterator.next(); if (firstFlag) &#123; sb.append("?" + entry.getKey() + "=" + entry.getValue()); firstFlag = false; &#125; else &#123; sb.append("&amp;" + entry.getKey() + "=" + entry.getValue()); &#125; &#125; &#125; HttpGet httpGet = new HttpGet(sb.toString()); //设置超时 httpGet.setConfig(this.requestConfig); //请求数据 CloseableHttpResponse response = null; try &#123; response = this.httpClient.execute(httpGet); int status = response.getStatusLine().getStatusCode(); if (status == HttpStatus.SC_OK) &#123; HttpEntity entity = response.getEntity(); BufferedInputStream bis = new BufferedInputStream(entity.getContent()); if (bis.available() &lt; 1024) &#123; bis.close(); return null; &#125; FileOutputStream fos = new FileOutputStream(file); byte[] buf = new byte[1024]; int size = 0; while ((size = bis.read(buf)) != -1) &#123; fos.write(buf, 0, size); &#125; fos.close(); bis.close(); &#125; &#125; catch (Exception ex) &#123; logger.error("http error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(ex)); file.delete(); return null; &#125; finally &#123; if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; logger.error("http close error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; &#125; &#125; return file; &#125; /** * post * * @param url 请求的url * @param queries 请求的参数，在浏览器？后面的数据，没有可以传null * @param params post form 提交的参数 * @return */ public String post(String url, Map&lt;String, String&gt; queries, Map&lt;String, String&gt; params) &#123; String responseBody = ""; StringBuffer sb = new StringBuffer(url); if (queries != null &amp;&amp; queries.keySet().size() &gt; 0) &#123; boolean firstFlag = true; Iterator iterator = queries.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) iterator.next(); if (firstFlag) &#123; sb.append("?" + entry.getKey() + "=" + entry.getValue()); firstFlag = false; &#125; else &#123; sb.append("&amp;" + entry.getKey() + "=" + entry.getValue()); &#125; &#125; &#125; //指定url,和http方式 HttpPost httpPost = new HttpPost(sb.toString()); httpPost.setConfig(this.requestConfig); //添加参数 List&lt;NameValuePair&gt; nvps = new ArrayList&lt;&gt;(); if (params != null &amp;&amp; params.keySet().size() &gt; 0) &#123; for (String key : params.keySet()) &#123; nvps.add(new BasicNameValuePair(key, params.get(key))); &#125; &#125; httpPost.setEntity(new UrlEncodedFormEntity(nvps, Consts.UTF_8)); //请求数据 CloseableHttpResponse response = null; try &#123; response = this.httpClient.execute(httpPost); if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; HttpEntity entity = response.getEntity(); responseBody = EntityUtils.toString(entity);// EntityUtils.consume(response.getEntity()); //会自动释放连接 &#125; &#125; catch (IOException ex) &#123; logger.error("http error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(ex)); &#125; finally &#123; if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; logger.error("http close error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; &#125; &#125; return responseBody; &#125; /** * post * * @param url 请求的url * @param data post json 提交的参数 * @return */ public String post(String url, String data) &#123; String responseBody = ""; StringBuffer sb = new StringBuffer(url); //指定url,和http方式 HttpPost httpPost = new HttpPost(sb.toString()); httpPost.setConfig(this.requestConfig); //设置类型 StringEntity se = new StringEntity(data, "utf-8"); se.setContentEncoding(new BasicHeader(HTTP.CONTENT_TYPE, "application/json")); httpPost.setEntity(se); //请求数据 CloseableHttpResponse response = null; try &#123; response = this.httpClient.execute(httpPost); if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; HttpEntity entity = response.getEntity(); responseBody = EntityUtils.toString(entity); &#125; &#125; catch (IOException ex) &#123; logger.error("http post error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(ex)); &#125; finally &#123; if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; logger.error("http post close error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; &#125; &#125; return responseBody; &#125;&#125; 使用方法12@Resourceprivate HttpClientUtil httpClientUtil;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[不同版本(2.5-3.1) web.xml文件的schema头部声明]]></title>
      <url>%2F2017%2F04%2F25%2F%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC-2-5-3-1-web-xml%E6%96%87%E4%BB%B6%E7%9A%84schema%E5%A4%B4%E9%83%A8%E5%A3%B0%E6%98%8E%2F</url>
      <content type="text"><![CDATA[项目用的容器是tomcat8, tomcat8 默认的是servlet 3.1的版本, 看了下 web.xml还是3.0的版本, 所以升级了下, 顺便贴一下2.5到3.1的schema头部声明。 1. Servlet 3.1Java EE 7 XML schema，命名空间是 http://xmlns.jcp.org/xml/ns/javaee/ 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;/web-app&gt; 2. Servlet 3.0Java EE 6 XML schema，命名空间是 http://java.sun.com/xml/ns/javaee 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt;&lt;/web-app&gt; 3. Servlet 2.5Java EE 5 XML schema，命名空间是 http://java.sun.com/xml/ns/javaee 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt;&lt;/web-app&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring 集成 okhttp3]]></title>
      <url>%2F2017%2F04%2F21%2Fspring-%E9%9B%86%E6%88%90-okhttp3%2F</url>
      <content type="text"><![CDATA[前言okhttp 介绍 HTTP is the way modern applications network. It’s how we exchange data &amp; media. &gt;Doing HTTP efficiently makes your stuff load faster and saves bandwidth. OkHttp is an HTTP client that’s efficient by default: HTTP/2 support allows all requests to the same host to share a socket. Connection pooling reduces request latency (if HTTP/2 isn’t available). Transparent GZIP shrinks download sizes. Response caching avoids the network completely for repeat requests. OkHttp perseveres when the network is troublesome: it will silently recover from &gt; &gt;common connection problems. If your service has multiple IP addresses OkHttp will &gt;attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6 &gt;and for services hosted in redundant data centers. OkHttp initiates new connections &gt;with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake fails. Using OkHttp is easy. Its request/response API is designed with fluent builders and immutability. It supports both synchronous blocking calls and async calls with callbacks. OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7. —摘自 https://square.github.io/okhttp/ 准备工作在pom.xml文件中增加以下依赖12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt; 书写配置类 用@Configuration注解该类，等价与XML中配置beans；用@Bean标注方法等价于XML中配置bean。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Configurationpublic class OkHttpConfiguration &#123; @Bean public X509TrustManager x509TrustManager() &#123; return new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125;; &#125; @Bean public SSLSocketFactory sslSocketFactory() &#123; try &#123; //信任任何链接 SSLContext sslContext = SSLContext.getInstance("TLS"); sslContext.init(null, new TrustManager[]&#123;x509TrustManager()&#125;, new SecureRandom()); return sslContext.getSocketFactory(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * Create a new connection pool with tuning parameters appropriate for a single-user application. * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently */ @Bean public ConnectionPool pool() &#123; return new ConnectionPool(200, 5, TimeUnit.MINUTES); &#125; @Bean public OkHttpClient okHttpClient() &#123; return new OkHttpClient.Builder() .sslSocketFactory(sslSocketFactory(), x509TrustManager()) .retryOnConnectionFailure(false)//是否开启缓存 .connectionPool(pool())//连接池 .connectTimeout(10L, TimeUnit.SECONDS) .readTimeout(10L, TimeUnit.SECONDS) .build(); &#125;&#125; 工具类 自己写的工具类，比较简单，不是REST风格 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147@Componentpublic class OkHttpUtil &#123; private static final Logger logger = LoggerFactory.getLogger(OkHttpUtil.class); @Resource private OkHttpClient okHttpClient; /** * get * * @param url 请求的url * @param queries 请求的参数，在浏览器？后面的数据，没有可以传null * @return */ public String get(String url, Map&lt;String, String&gt; queries) &#123; String responseBody = ""; StringBuffer sb = new StringBuffer(url); if (queries != null &amp;&amp; queries.keySet().size() &gt; 0) &#123; boolean firstFlag = true; Iterator iterator = queries.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry&lt;String, String&gt;) iterator.next(); if (firstFlag) &#123; sb.append("?" + entry.getKey() + "=" + entry.getValue()); firstFlag = false; &#125; else &#123; sb.append("&amp;" + entry.getKey() + "=" + entry.getValue()); &#125; &#125; &#125; Request request = new Request .Builder() .url(sb.toString()) .build(); Response response = null; try &#123; response = okHttpClient.newCall(request).execute(); int status = response.code(); if (status == 200) &#123; return response.body().string(); &#125; &#125; catch (Exception e) &#123; logger.error("okhttp put error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; finally &#123; if (response != null) &#123; response.close(); &#125; &#125; return responseBody; &#125; /** * post * * @param url 请求的url * @param params post form 提交的参数 * @return */ public String post(String url, Map&lt;String, String&gt; params) &#123; String responseBody = ""; FormBody.Builder builder = new FormBody.Builder(); //添加参数 if (params != null &amp;&amp; params.keySet().size() &gt; 0) &#123; for (String key : params.keySet()) &#123; builder.add(key, params.get(key)); &#125; &#125; Request request = new Request .Builder() .url(url) .post(builder.build()) .build(); Response response = null; try &#123; response = okHttpClient.newCall(request).execute(); int status = response.code(); if (status == 200) &#123; return response.body().string(); &#125; &#125; catch (Exception e) &#123; logger.error("okhttp post error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; finally &#123; if (response != null) &#123; response.close(); &#125; &#125; return responseBody; &#125; /** * post 上传文件 * * @param url * @param params * @param fileType * @return */ public String postFile(String url, Map&lt;String, Object&gt; params, String fileType) &#123; String responseBody = ""; MultipartBody.Builder builder = new MultipartBody.Builder(); //添加参数 if (params != null &amp;&amp; params.keySet().size() &gt; 0) &#123; for (String key : params.keySet()) &#123; if (params.get(key) instanceof File) &#123; File file = (File) params.get(key); builder.addFormDataPart(key, file.getName(), RequestBody.create(MediaType.parse(fileType), file)); continue; &#125; builder.addFormDataPart(key, params.get(key).toString()); &#125; &#125; Request request = new Request .Builder() .url(url) .post(builder.build()) .build(); Response response = null; try &#123; response = okHttpClient.newCall(request).execute(); int status = response.code(); if (status == 200) &#123; return response.body().string(); &#125; &#125; catch (Exception e) &#123; logger.error("okhttp postFile error &gt;&gt; ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; finally &#123; if (response != null) &#123; response.close(); &#125; &#125; return responseBody; &#125;&#125; 使用方法12@Resourceprivate OkHttpUtil okHttpUtil;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring 集成 websocket]]></title>
      <url>%2F2017%2F04%2F21%2Fspring-%E9%9B%86%E6%88%90-websocket%2F</url>
      <content type="text"><![CDATA[spring4.0以后加入了对websocket技术的支持，目前项目用的是SSM（springMVC+spring+MyBatis）框架，所以选择了spring自带的websocket。 开始集成:在pom.xml文件中增加以下依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.websocket&lt;/groupId&gt; &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 握手拦截器12345678910111213141516171819public class WebSocketHandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123; @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; if (request instanceof ServletServerHttpRequest) &#123; String openid = ((ServletServerHttpRequest) request).getServletRequest().getParameter("openid"); attributes.put("WEBSOCKET_USERNAME", openid); &#125; return super.beforeHandshake(request, response, wsHandler, attributes); &#125; @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) &#123; super.afterHandshake(request, response, wsHandler, ex); &#125;&#125; 业务拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class UnionpaySocketHandler extends TextWebSocketHandler &#123; private static final Logger logger = LoggerFactory.getLogger(UnionpaySocketHandler.class); private final static ConcurrentMap&lt;String, WebSocketSession&gt; sessions; static &#123; sessions = new ConcurrentHashMap&lt;&gt;(); &#125; //接收文本消息，并发送出去 @Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123; String msg = message.getPayload(); TextMessage returnMessage = new TextMessage(msg); session.sendMessage(returnMessage); super.handleTextMessage(session, message); &#125; //连接建立后处理 @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; String openid = (String) session.getAttributes().get("WEBSOCKET_USERNAME"); if (StringUtils.isNotBlank(openid)) &#123; logger.info("用户 &gt;&gt; &#123;&#125; 建立连接", openid); sessions.put(openid, session); &#125; &#125; //抛出异常时处理 @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; if (session.isOpen()) &#123; session.close(); &#125; String openid = (String) session.getAttributes().get("WEBSOCKET_USERNAME"); sessions.remove(openid); &#125; //连接关闭后处理 @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception &#123; String openid = (String) session.getAttributes().get("WEBSOCKET_USERNAME"); logger.info("用户 &gt;&gt; &#123;&#125; 退出连接", openid); sessions.remove(openid); &#125; /** * 给某个用户发送消息 * * @param userName * @param msg */ public void sendMessageToUser(String userName, String msg) &#123; WebSocketSession session = sessions.get(userName); if (session != null) &#123; try &#123; TextMessage message = new TextMessage(msg); session.sendMessage(message); &#125; catch (IOException e) &#123; logger.error("发送信息异常, ex = &#123;&#125;", ExceptionUtils.getStackTrace(e)); &#125; &#125; &#125;&#125; 配置类12345678910111213141516171819202122232425262728@Configuration@EnableWebSocketpublic class WebSocketConfiguration implements WebSocketConfigurer &#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; registry .addHandler(unionpaySocketHandler(), "/unionpayServer") .setAllowedOrigins("*")//允许所有域访问 .addInterceptors(myInterceptor()); registry .addHandler(unionpaySocketHandler(), "/unionpayServer/sockjs") .setAllowedOrigins("*") .addInterceptors(myInterceptor()) .withSockJS(); &#125; @Bean public UnionpaySocketHandler unionpaySocketHandler() &#123; return new UnionpaySocketHandler(); &#125; @Bean public WebSocketHandshakeInterceptor myInterceptor() &#123; return new WebSocketHandshakeInterceptor(); &#125;&#125; web.xml增加配置12345678910&lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; **&lt;async-supported&gt;true&lt;/async-supported&gt;//需要增加此项 允许异步(未测试是否必须配置)&lt;/servlet&gt; 以下重点如果使用了nginx做代理，则nginx需要增加配置，否则websocket开启会报错301或者400或者500等 以下为例子 1234567location /websocket &#123; proxy_pass http://127.0.0.1:9090/unionpayServer; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_read_timeout 300s;&#125; 前端调用方法示例1websocket = new WebSocket("ws://localhost:8080/websocket?openid=123");//如果为https,ws改为wss 至此，整个websocket集成配置已完成。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F20%2Fhello%20world%2F</url>
      <content type="text"><![CDATA[Hello, this world！ 没有啦~~~]]></content>
    </entry>

    
  
  
</search>
